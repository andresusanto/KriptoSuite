/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.andresusanto.engine;

import com.andresusanto.object.Picture;
import com.andresusanto.object.Payload;
import com.andresusanto.object.BitCoordinate;
import com.andresusanto.object.Segmen;
import java.io.IOException;
import java.util.ArrayList;

/**
 *
 * @author Andre
 */
public class BPCS {
    // format header data yang disisipkan
    // 1. 4 bytes (int) = ukuran file yang disisipkan
    // 2. 1 byte = panjang ekstensi file
    // 3. N byte (N ditentukan oleh panjang ekstensi) = ekstensi file
    // Sehingga payload yang disisipkan : [4 bytes | 1 byte | N byte | KONTEN]
    
    private Picture picture;
    private float threshold;
    private String key;
    private int capacity; //capacity in byte
    private int capacityBlock; //capacity in blocks
    private ArrayList<BitCoordinate> taggedBitplane;
    private boolean didOnce; //Indicator if picture is already manipulated
    
    public BPCS(Picture picture, float threshold) {
        this.picture = picture;
        this.threshold = threshold;
        didOnce = false;
        prepareBPCS();
    }
    
    public BPCS(String key, Picture picture, float threshold){ // key menjadi seed dari random number generator tempat menyimpan data
        this.key = key;
        this.picture = picture;
        this.threshold = threshold;
        didOnce = false;
        prepareBPCS();
    }
    
    public int getCapacity() {
        return capacity;
    }
    
    public boolean isDidOnce() {
        return didOnce;
    }
    
    public void setKey(String key) {
        this.key = key;
    }
    
    // sisipkan data ke pic
    public void embed(Payload data) throws IOException{ // throw exception jika data > payload
        /**
         * 1. Ambil total blok-blok piksel 8x8
         * 2. Ubah setiap bitplane menjadi CGC sambil menghitung dan menyimpan
         *      posisi dimana pesan bisa dimasukkan
         * 3. Bandingkan ukuran pesan dengan jumlah bitplane yang bisa dimasukkan
         * 4. Jika memungkinkan, acak segmen segmen pesan
         * 5. Masukkan segmen yang telah diacak ke dalam bitplane
         * 6. Lakukan konversi balik dari CGC menjadi PBC
         */
        
        //Converting to CGC already done on preparation step
        
        /**
         * Check if embedding is possible
         */
        ArrayList<Segmen> dataSegmen = data.getAllSegments();

        if(capacityBlock < dataSegmen.size()) {
            //Inserted data too big, refusing
            throw new IOException("Data yang akan dimasukkan terlalu besar!");
        } 
        
        /**
         * Proceeding to insert the data
         * Initialize a randomizer which will act as table of placement
         */
        int[] randomizedIndex = Tools.getShuffledInts(key, 0, capacityBlock - 1);

        int i;
        //Place the data according to table randomizedIndex
        for (i=0; i < dataSegmen.size(); i++) {
            Segmen currentSegmen = dataSegmen.get(i);
            BitCoordinate currentCoordinate = taggedBitplane.get(randomizedIndex[i]);
            int region = currentCoordinate.getRegion();
            int layer = currentCoordinate.getBitplane();
            char colorCode = currentCoordinate.getColor();
            boolean[] currentData = currentSegmen.getData();
            picture.setBitPlane(region, layer, colorCode, currentData);
        }
        
        convertAllBackToPBC();
        didOnce = true;
    }
    
    // ekstrak data ke pic
    public Payload extract() throws Exception{
        /**
         * 1. Ambil jumlah blok pixel
         * 2. Ubah setiap bitplane menjadi CGC sambil menyimpan letak koordinat pesan
         * 3. Susun kembali semua pesan yang sudah diacak sebelumnya ketika embed
         * 4. Bentuk payload baru
         * 5. Ubah kembali ke PBC (cleanup)
         */
        
        int i;
        
        // Conversion to CGC and counting already done at preparation step
        
        /**
         * Proceeding to insert the data
         */
        //Generate table of random placement (should be same result with one generated by embed)
        int[] randomizedIndex = Tools.getShuffledInts(key, 0, capacityBlock - 1);

        //Get 1st block
        BitCoordinate ptrToFirstBlock = taggedBitplane.get(randomizedIndex[0]);
        int firstBlockRegion = ptrToFirstBlock.getRegion();
        int firstBlockLayer = ptrToFirstBlock.getBitplane();
        char firstBlockColor = ptrToFirstBlock.getColor();
        boolean[] firstBlockData = picture.getBitPlane(firstBlockRegion, firstBlockLayer, firstBlockColor);
        Segmen firstSegmen = new Segmen(firstBlockData, threshold);
        //Get 2nd block
        BitCoordinate ptrToSecondBlock = taggedBitplane.get(randomizedIndex[1]);
        int secondBlockRegion = ptrToSecondBlock.getRegion();
        int secondBlockLayer = ptrToSecondBlock.getBitplane();
        char secondBlockColor = ptrToSecondBlock.getColor();
        boolean[] secondBlockData = picture.getBitPlane(secondBlockRegion, secondBlockLayer, secondBlockColor);
        Segmen secondSegmen = new Segmen(secondBlockData, threshold);
        
        int payloadNumOfBlocks = Payload.getNumOfSegmensFromHeader(firstSegmen, secondSegmen);
        ArrayList<boolean[]> payloadData = new ArrayList<>();
        
        //Add first block, second block and fetch the rest of payload block
        payloadData.add(firstBlockData);
        payloadData.add(secondBlockData);
        for (i=2; i < payloadNumOfBlocks; i++) {
            BitCoordinate currentCoordinate = taggedBitplane.get(randomizedIndex[i]);
            int region = currentCoordinate.getRegion();
            int layer = currentCoordinate.getBitplane();
            char colorCode = currentCoordinate.getColor();
            boolean[] currentBitplane = picture.getBitPlane(region, layer, colorCode);
            payloadData.add(currentBitplane);
        }
        
        /**
         * Put bitplane to new payload for return
         */
        Payload ret = new Payload(payloadData, key);
        
        convertAllBackToPBC();
        
        return ret;
    }
    
    // fungsi untuk menghitung komplesitas suatu bitplane
    private float calculateComplexity(boolean bitPlane[], int layer, char colorCode){ // karena gambar dibagi menjadi 8 x 8 pixel, maka setiap bagian dinyatakan sbg region
        //boolean[] bitPlane = picture.getBitPlane(region, layer, colorCode);
        float complexity = 0;
        
        for (int y = 0; y < 8; y++){
            for (int x = 0; x < 8; x++){
                if (!bitPlane[y * 8 + x]) continue;
                
                if (y > 0 && !bitPlane[(y - 1) * 8 + x]) complexity++;
                if (x > 0 && !bitPlane[y * 8 + (x - 1)]) complexity++;
                if (y + 1 < 8 && !bitPlane[(y + 1) * 8 + x]) complexity++;
                if (x + 1 < 8 && !bitPlane[y * 8 + (x + 1)]) complexity++;
            }
        }
        return complexity / 112.0f; // maks kompleksitas adl:  ((nrows-1)*ncols) + ((ncols-1)*nrows)
    }
    
    
    // ---
    // CGC PBC
    // catatan: semua manipulasi terhadap gambar langsung kepada objek picture
    // ---
    
    private void convertToCGC(int region, int layer, char colorCode){
        boolean[] currentBitplane = picture.getBitPlane(region, layer, colorCode);
        /**
         * Transform to 2D array
         */
        int x,y,i;
        i = 0;
        boolean[][] transformedBitplane = new boolean[8][8];
        for (y=0; y < transformedBitplane.length; y++) {
            for (x=0; x < transformedBitplane.length; x++) {
                transformedBitplane[x][y] = currentBitplane[i];
                i++;
            }
        }
        
        boolean[][] convertedBitplane = new boolean[8][8];
        for (y=0; y < transformedBitplane.length; y++) {
            for (x=0; x < transformedBitplane.length; x++) {
                if (x==0) {
                    convertedBitplane[x][y] = transformedBitplane[x][y];
                } else {
                    convertedBitplane[x][y] = transformedBitplane[x-1][y] ^ transformedBitplane[x][y];
                }
            }
        }
        
        
        /**
         * Retransform back to 1D array
         */
        boolean[] currentConvertedBitplane = new boolean[currentBitplane.length];
        i = 0;
        for (y=0; y < convertedBitplane.length; y++) {
            for (x=0; x < convertedBitplane.length; x++) {
                currentConvertedBitplane[i] = convertedBitplane[x][y];
                i++;
            }
        }
        /**
         * Set bitplane
         */
        picture.setBitPlane(region, layer, colorCode, currentConvertedBitplane);
    }
    
    private void convertToPBC(int region, int layer, char colorCode){
        boolean[] currentBitplane = picture.getBitPlane(region, layer, colorCode);
        /**
         * Transform to 2D array
         */
        int x,y,i;
        i = 0;
        boolean[][] transformedBitplane = new boolean[8][8];
        for (y=0; y < transformedBitplane.length; y++) {
            for (x=0; x < transformedBitplane.length; x++) {
                transformedBitplane[x][y] = currentBitplane[i];
                i++;
            }
        }
        
        boolean[][] convertedBitplane = new boolean[8][8];
        for (y=0; y < transformedBitplane.length; y++) {
            for (x=0; x < transformedBitplane.length; x++) {
                if (x==0) {
                    convertedBitplane[x][y] = transformedBitplane[x][y];
                } else {
                    convertedBitplane[x][y] = convertedBitplane[x-1][y] ^ transformedBitplane[x][y];
                }
            }
        }
        
        /**
         * Retransform back to 1D array
         */
        boolean[] currentConvertedBitplane = new boolean[currentBitplane.length];
        i = 0;
        for (y=0; y < convertedBitplane.length; y++) {
            for (x=0; x < convertedBitplane.length; x++) {
                currentConvertedBitplane[i] = convertedBitplane[x][y];
                i++;
            }
        }
        /**
         * Set bitplane
         */
        picture.setBitPlane(region, layer, colorCode, currentConvertedBitplane);
        
    }
    
    public void prepareBPCS(){
        int bitplaneCount = picture.getTotalRegions();
        this.taggedBitplane = new ArrayList<>();
        int i,j,k;
        /**
         * Following parts will only convert (and convert back) and count insertable bitplane location
         * i = region
         * j = layer
         * k = color code
         */
        for (i=0; i < bitplaneCount; i++) {
            for (j=0; j < 8; j++) {
                for(k=0; k < 3; k++) {
                    char colorCode;
                    switch(k) {
                        case (0): colorCode = 'R';
                            break;
                        case (1): colorCode = 'G';
                            break;
                        case (2): colorCode = 'B';
                            break;
                        default: colorCode = 'E'; //actually just to silence the compiler
                            break;
                    }
                    //Convert to CGC while counting insertable bitplane, then add to taggedBitplane
                    convertToCGC(i, j, colorCode);
                    boolean[] currentBitplane = picture.getBitPlane(i, j, colorCode);
                    float complexity = calculateComplexity(currentBitplane, j, colorCode);
                    if (complexity > threshold) {
                        //Insertable bitplane found
                        taggedBitplane.add(new BitCoordinate(i,j,colorCode));
                    }
                }
            }
        }
        this.capacityBlock = taggedBitplane.size();
        this.capacity = (taggedBitplane.size() * 63/8 ) - 16; // total capacity in byte, for display purpose
    }
    
    private void convertAllBackToPBC() {
        /**
         * Turn back coding to PBC
         */
        int i,j,k;
        int bitplaneCount = picture.getTotalRegions();
        for (i=0; i < bitplaneCount; i++) {
            for (j=0; j < 8; j++) {
                for(k=0; k < 3; k++) {
                    char colorCode;
                    switch(k) {
                        case (0): colorCode = 'R';
                            break;
                        case (1): colorCode = 'G';
                            break;
                        case (2): colorCode = 'B';
                            break;
                        default: colorCode = 'E'; //actually just to silence the compiler
                            break;
                    }
                    convertToPBC(i, j, colorCode);
                }
            }
        }
    }
}